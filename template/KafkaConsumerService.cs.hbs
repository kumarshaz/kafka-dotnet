using System;
using System.Threading;
using System.Threading.Tasks;
using Confluent.Kafka;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using {{namespace}}.Serialization;

namespace {{namespace}}.Kafka
{
    public class KafkaConfig
    {
        public string BootstrapServers { get; set; }
        public string SchemaRegistryUrl { get; set; }
        public string ConsumerGroupId { get; set; }
        public bool UseAvroSerialization { get; set; }
    }

    public partial class KafkaConsumerService : BackgroundService
    {
        private readonly ILogger<KafkaConsumerService> _logger;
        private readonly KafkaConfig _kafkaConfig;
        private readonly ISerializationService _serializationService;

        public KafkaConsumerService(
            ILogger<KafkaConsumerService> logger,
            IOptions<KafkaConfig> kafkaOptions,
            ISerializationService serializationService)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _kafkaConfig = kafkaOptions?.Value ?? throw new ArgumentNullException(nameof(kafkaOptions));
            _serializationService = serializationService ?? throw new ArgumentNullException(nameof(serializationService));
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            _logger.LogInformation("Kafka Consumer Service is starting...");

            // Start consumers for each topic
            var consumerTasks = new List<Task>();
            {{#each operations.subscribe}}
            consumerTasks.Add(Consume{{toPascalCase topicName}}(stoppingToken));
            {{/each}}

            // Wait for all consumers to complete
            await Task.WhenAll(consumerTasks);
            _logger.LogInformation("Kafka Consumer Service is stopping...");
        }
    }
}

{{#each operations.subscribe}}
{{> kafkaConsumer operation=this}}
{{/each}}
